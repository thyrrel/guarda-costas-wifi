"import 'dart:async';\nimport 'dart:convert';\nimport 'dart:math';\nimport 'package:http_server/http_server.dart';\nimport 'package:shelf/shelf.dart';\nimport 'package:shelf/shelf_io.dart' as io;\nimport 'package:shelf_web_socket/shelf_web_socket.dart';\nimport 'package.dart';\n\nclass SimulatedAgentService {\n  HttpServer? _server;\n  final List<WebSocketChannel> _clients = [];\n  final StreamController<String> _logStreamController = StreamController.broadcast();\n  Stream<String> get logStream => _logStreamController.stream;\n\n  Timer? _bandwidthTimer;\n  final List<Map<String, dynamic>> _devices = [];\n\n  SimulatedAgentService() {\n    _initializeDevices();\n  }\n\n  void _log(String message) {\n    final timestamp = DateFormat('HH:mm:ss').format(DateTime.now());\n    _logStreamController.add('[\$timestamp] \$message');\n  }\n\n  void _initializeDevices() {\n    _devices.addAll([\n      {'ipAddress': '192.168.1.1', 'macAddress': '00:1A:2B:3C:4D:5E', 'hostname': 'Roteador Principal', 'isBlocked': false},\n      {'ipAddress': '192.168.1.101', 'macAddress': 'AA:BB:CC:DD:EE:FF', 'hostname': 'iPhone de João', 'isBlocked': false},\n      {'ipAddress': '192.168.1.102', 'macAddress': '11:22:33:44:55:66', 'hostname': 'SmartTV da Sala', 'isBlocked': false},\n      {'ipAddress': '192.168.1.103', 'macAddress': 'A1:B2:C3:D4:E5:F6', 'hostname': 'Notebook-Trabalho', 'isBlocked': true},\n    ]);\n  }\n\n  Future<void> start() async {\n    if (_server != null) {\n      _log('Agente já está em execução.');\n      return;\n    }\n    try {\n      var handler = const Pipeline()\n          .addMiddleware(logRequests())\n          .addHandler(_handleRequest);\n\n      _server = await io.serve(handler, '127.0.0.1', 8080);\n      _log('Agente iniciado em http://\${_server!.address.host}:\${_server!.port}');\n      \n      _bandwidthTimer = Timer.periodic(const Duration(seconds: 2), (_) => _simulateBandwidthUsage());\n    } catch (e) {\n      _log('Erro ao iniciar o agente: \$e');\n    }\n  }\n\n  Future<void> stop() async {\n    await _server?.close(force: true);\n    _bandwidthTimer?.cancel();\n    _clients.clear();\n    _server = null;\n    _log('Agente parado.');\n  }\n\n  void dispose() {\n    _logStreamController.close();\n    stop();\n  }\n\n  Handler _handleRequest(Request request) {\n    if (request.url.path == 'ws') {\n      return webSocketHandler((WebSocketChannel client) {\n        _log('Novo cliente conectado ao WebSocket.');\n        _clients.add(client);\n        client.stream.listen((message) {\n          _log('Mensagem recebida do cliente: \$message');\n        }, onDone: () {\n          _log('Cliente desconectado.');\n          _clients.remove(client);\n        });\n      });\n    }\n    if (request.url.path == 'api/devices' && request.method == 'GET') {\n      return Response.ok(jsonEncode(_devices), headers: {'Content-Type': 'application/json'});\n    }\n    if (request.url.path == 'api/block' && request.method == 'POST') {\n      return (Request innerRequest) async {\n        final body = await innerRequest.readAsString();\n        final mac = jsonDecode(body)['macAddress'];\n        _updateDeviceBlockStatus(mac, true);\n        _broadcastUpdate('device_updated', {'macAddress': mac, 'isBlocked': true});\n        return Response.ok('Dispositivo bloqueado');\n      };\n    }\n    if (request.url.path == 'api/unblock' && request.method == 'POST') {\n      return (Request innerRequest) async {\n        final body = await innerRequest.readAsString();\n        final mac = jsonDecode(body)['macAddress'];\n        _updateDeviceBlockStatus(mac, false);\n        _broadcastUpdate('device_updated', {'macAddress': mac, 'isBlocked': false});\n        return Response.ok('Dispositivo desbloqueado');\n      };\n    }\n    return Response.notFound('Endpoint não encontrado.');\n  }\n\n  void _updateDeviceBlockStatus(String mac, bool isBlocked) {\n    final index = _devices.indexWhere((d) => d['macAddress'] == mac);\n    if (index != -1) {\n      _devices[index]['isBlocked'] = isBlocked;\n      _log('Status de bloqueio atualizado para \$mac: \$isBlocked');\n    }\n  }\n\n  void _broadcastUpdate(String type, dynamic data) {\n    final message = jsonEncode({'type': type, 'payload': data});\n    _log('Transmitindo atualização: \$type');\n    for (var client in _clients) {\n      client.sink.add(message);\n    }\n  }\n\n  void simulateNewDevice() {\n    final randomMac = List.generate(6, (_) => Random().nextInt(256).toRadixString(16).padLeft(2, '0')).join(':').toUpperCase();\n    final newDevice = {\n      'ipAddress': '192.168.1.\${110 + Random().nextInt(50)}',\n      'macAddress': randomMac,\n      'hostname': 'Dispositivo Aleatório',\n      'isBlocked': false\n    };\n    _devices.add(newDevice);\n    _log('EVENTO: Novo dispositivo simulado adicionado: \$randomMac');\n    _broadcastUpdate('device_added', newDevice);\n  }\n  \n  void _simulateBandwidthUsage() {\n    if (_clients.isEmpty) return;\n\n    final usageData = _devices.map((device) {\n      final download = Random().nextDouble() * (device['hostname']!.contains('TV') ? 50 : 5);\n      final upload = Random().nextDouble() * 2;\n      return {\n        'macAddress': device['macAddress'],\n        'download_mbps': download,\n        'upload_mbps': upload,\n      };\n    }).toList();\n\n    _broadcastUpdate('bandwidth_update', usageData);\n  }\n}"